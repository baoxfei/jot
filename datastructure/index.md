# 数据结构与算法

## 四大思想

### 回溯算法

  > 思想：
  > 回溯算法（Backtracking Algorithm）是一种递归搜索算法，用于解决组合优化问题、排列问题、搜索问题以及决策问题。它的核心思想是通过不断试错，逐步构建解决方案，如果发现当前的选择不符合问题的要求，就回退到上一步，尝试其他可能的选择，直到找到解决方案或确定无解。
  >
#### 适用场景

1. 组合问题：从一组元素中选择一个子集，使得满足特定条件，例如子集的和等于特定值。

2. 排列问题：对一组元素进行排列，找出所有可能的排列，或者找到符合条件的排列。

3. 图问题：在图结构中查找路径、寻找最短路径等问题。

4. 搜索问题：在搜索空间中找到满足一定条件的解。

5. 决策问题：做出一系列决策，以找到一个或多个最优解。

#### 模版/流程

- 从问题的初始状态开始。
- 选择一个可能的候选解，通常是根据某种规则或策略选择。
- 检查候选解是否满足问题的要求。
  - 如果满足，保存候选解并继续下一步。
  - 如果不满足，回退到上一步，选择其他候选解。
  重复步骤 2 和 3，直到找到解决方案或确定无解。
- 如果找到解决方案，返回解决方案。如果确定无解，也返回无解的标志。

**回溯算法是一种穷举搜索的方法，它会搜索所有可能的解空间，因此在某些情况下，其时间复杂度可能会很高。为了提高效率，可以使用剪枝策略来减少搜索的空间。回溯算法通常借助递归来实现，每一层递归代表问题中的一个决策点。**

#### 经典问题

1. 八皇后问题
2. 0-1背包问题
3. 旅行推销员问题

### 贪心算法

>思想：
>在每一步都做出当前看似最佳的选择，以期望最终获得全局最佳解

#### 适用场景

1. 那些具有最优子结构（Optimal Substructure）和贪心选择性质（Greedy Choice Property）的问题
2. 通常用于解决组合优化问题
3. 需要高效性能的情况下，它常常是一种可行的选择。

#### 模版/流程

1. 初始化：根据问题的要求进行初始设置。

2. 贪心选择：在每一步选择当前情况下看起来最优的解决方案。这一步基于局部最优原则，不考虑未来可能出现的情况。

3. 检查可行性：检查所选择的解决方案是否满足问题的约束和要求。

4. 执行选择：如果所选解决方案有效，则将其添加到解决方案中，否则放弃并回到上一步。

5. 终止条件：重复步骤 2 到 4，直到满足终止条件。

6. 输出解决方案：返回所得到的解决方案，它可能是一个近似最优解。

**贪心算法的优点在于它通常比其他优化算法更高效，因为它通常不需要进行大规模的搜索或计算。然而，贪心算法并不总是能够找到全局最优解，因为它忽略了未来可能的情况。因此，在使用贪心算法时，需要确保问题满足贪心选择性质和最优子结构，以获得合理的解。**

#### 经典问题

1. 钱币找零问题：找零时使用最少数量的硬币。

```js
// 给定一组面额不同的硬币 coins 和一个总金额 amount，找出可以凑出总金额的最少硬币数量。如果无法凑出总金额，返回 -1。
// 例如，假设硬币面额为 [1, 2, 5]，总金额为 11。要找零 11 元，可以使用三枚硬币：2 元、5 元和 5 元，所以最少需要 3 枚硬币
const coinChange = function(coins, amount) {
  coins.sort((a, b) => a - b)
  let remainder
  const result = []
  // let 
  while (condition) {
    
  }
}
```

2. 背包问题：选择一组物品放入背包以最大化价值。
3. 最小生成树问题：找到一棵包含所有节点且边权重最小的树。
4. 哈夫曼编码：用于数据压缩的编码算

### 动态规划

### 分治算法

## 数据结构

### 栈

### 队列

### 链表

### 二叉树

### 字典

## 技巧

### 双指针

 1. 快慢指针

    - 用于解决链表中的一些问题，如判断链表是否有环、找到环的起点、求链表的中间节点等。
    - 一快一慢两个指针，快指针每次移动两步，慢指针每次移动一步。如果有环，快指针最终会追上慢指针。

 2. 左右指针（两端扫描）
    - 用于解决数组或字符串中的一些问题，如求两数之和、三数之和等。
    - 一般情况下，左右指针分别指向数组的两端，通过移动指针来寻找目标。
 3. 滑动窗口

    - 用于解决一些子数组或子字符串的问题，如最小覆盖子串、最长无重复字符子串等。
    - 通过维护一个窗口，可以在数组或字符串上进行滑动，并在滑动过程中更新窗口的状态。

 4. 对撞指针

    - 用于解决有序数组或链表中的一些问题，如两数之和、反转链表等。
    - 两个指针分别从数组或链表的两端向中间移动，通过不同条件的判断来缩小问题的规模。

 5. 快慢指针（同向双指针）

    - 用于解决一些特定问题，如删除排序数组中的重复项、移除元素等。
    - 通过一个快指针和一个慢指针在同一个方向上移动，通过不同条件的判断来达到不同的目的。

#### 适用场景

## 数学

### 位运算
